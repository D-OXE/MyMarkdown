# 自动化管理线程
将thread放进vector,是实现自动线程自动化管理的关键步骤.



# 并发问题

## 超额认购问题

当启动的线程数量超过 **std::thread::hardware_concurrency() **返回的数量的时候,就会发生超额认购.发生这个问题时候,操作系统就需要通过**时间片轮转**频繁切换线程上下文,导致大量时间浪费在**上下文切换（Context Switching）**而非实际计算,最终降低并发性能.

> 进行并发之前,需要**确定并发的规模**,即确定启动线程的数量.这点很重要,能避免无谓的性能浪费

### 超额认购的负面影响

| 问题类型         | 具体表现                                    |
| :--------------- | :------------------------------------------ |
| **性能下降**     | 上下文切换开销可能占30%以上执行时间         |
| **缓存抖动**     | 不同线程频繁争夺CPU缓存，导致缓存命中率骤降 |
| **资源争用**     | 内存带宽、IO等资源成为瓶颈                  |
| **可预测性降低** | 执行时间波动大，难以进行性能调优            |

### 解决方法

1. 线程池

2. 合理的数量  -> std::thread::hardware_concurrency()

3. 任务窃取
 ```C++
    // 使用TBB库实现任务窃取
    #include <tbb/parallel_for.h>
    
    void parallel_processing() {
        tbb::parallel_for(0, 10000, [](int i) {
            // 自动负载均衡的任务分配
        });
    }
 ```