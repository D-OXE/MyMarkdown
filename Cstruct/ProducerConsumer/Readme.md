这是一个阻塞队列的简单实现,后续尝试和其他项目接轨,比如当作线程或者函数的容器 	-- 2025/4/3
顺便记录学习日志.

## 模板编程基础

 **.h文件中** 声明了模板函数,在.cpp文件中实现的时候,每个函数之前要加上**template<typename T>**, 或者class T ,并且对应的函数的命名空间后要加上<T>,如:

 ```C++
bool BlockQueue<T>::isFull() {
	return this->m_BQueue.size() == this->m_MaxSize;
}
 ```

 BlockQueue后面加上<T>, 而不是简单的:

 ```C++
bool BlockQueue::isFull() {
	return this->m_BQueue.size() == this->m_MaxSize;
}
 ```

 模板编程的源文件实现才算完成, 自然, 涉及到的变量, 模板变量都需要替换成 T .

经过不断的尝试, 得出结论:

**涉及到模板编程的东西,直接写.hpp文件,将函数实现全部写在声明文件中,不要分开编写**.

其他感悟,生命周期/参数传递. 尤其是EnQueue函数的完美转发的使用, 对比于(const T& pra)传递和(T pra)这两种形式的传递:

**1. 完美转发 VS const T& pra** :

**完美转发**: 可看作一个中转站, 想要用这个类(比如function)的原本类型,但是又不想额外触发不必要的拷贝或者移动,就可以使用完美转发, 完美转发可以自动将传入的参数进行折叠,从而完成无损的将参数传递到下游,比如EnQueue函数传递的参数,使用完美转发之后, 就可以无损传递到push函数中,至于push函数怎么传递,那是push 的事.

- 完美转发的优点:  最高效：**对右值避免拷贝，对左值保持引用**。 灵活性：可配合std::forward精确控制转发。

- 缺点就是可能**转发了局部变量,导致悬垂引用的问题**,其他的问题暂时不考虑,可以google.

**const T& pra** : 这个写法明确表示自己的**意图就是只读,不会对参数任何修改**. 能广泛的兼容左值和临时变量.

- 优点: 意图明显,兼容性不错

- 缺点: 没法触发移动语义, 造成拷贝而产生性能浪费

**1. 完美转发 VS T pra** :

完美转发的优点已经知道,传值的一些优劣:

- 优点: 直观,**对右值移动,对左值拷贝**, 缺点:对左值参数强制拷贝,不一定合适.

因此, 场景不太复杂的地方可以自行选择const T&或者T& 或者直接传值,但是场景一旦复杂或者涉及模板编程,可以直接使用完美转发.

> 如何界定复杂不复杂,比较主观,但是**常见的**比如int ,double ,std::string这种就不需要完美转发了, 完全可以根据上下文意思, 决定使用具体哪种传参方式. 像std::function可以考虑使用.对于本项目, push使用const T& 就可以了.因为**上游传递的变量本就经过了一次完美转发,不是右值就是左值,且不会改变**,只是执行,因此const T&就可以了,不用再写一次完美转发.

## 本项目的其他注意事项

### 线程同步控制

另外,对于本项目,尤其要注意,任务全部结束的时候,线程池需要唤醒一次所有的线程,这样才能结束进程的全部任务,否则很难继续.并且,在使用bool变量的时候,也最好使用atomic<bool>以避开并发问题.尤其是可能有多个无锁线程同时需要读取bool变量的时候,更需要使用atomic<bool>来解决这个问题.

**什么时候用bool?**

- 单线程

- 被互斥锁保护或者只读	

> --> 但是本项目中,stop是会修改的,也不是单线程的,并且被互斥锁保护的时候,**处理不当还会引发死锁(这个问题已经踩过坑了)**

因此,在多线程编程中,涉及到bool变量直接使用atomic<bool>就行了.使用的时候直接当作是bool就可以了,但是需要注意,atomic<bool>不可拷贝和移动.**为了减少和bool类型之间的无缝切换使用,以后在使用这俩变量时候,直接使用 = 指定赋值true或者false就行了.**关于判断,这个原子类**底层已经重载了== 号**,可以直接两个变量判断,也可以直接和false/true判断.**不整花活,就可以放心的用.**

> 详细使用方法一般不会用到, 用到再查是一样的.

其他的线程同步控制主要是记得多检查几个变量:

- 条件变量中,不仅检查线程池是否继续运行,还要检测队列是否空,因为只有stop为true,且队列空才是真正的结束.

- 每次条件变量wait结束之后,还要检测这两个标志为是否意味着任务全部结束,因为wait苏醒的条件,任务结束了也满足,也能唤醒线程继续向下,所以要检测一下,不是结束的条件,才能直接func()消耗任务,否则应该break或者return结束这个线程的执行,等待析构函数的join.

### 容器保管的元素

对于本项目,queue是个保管函数对象(function)的容器,值得注意的是这个东西的**pop函数,会直接销毁队列第一个元素,如果不对这个元素先进行移动语义的操作,就只能拷贝一个副本了.**恰好使用的函数对象是标准库实现的一个类,自己已经实现了移动语义,不需要手动实现,因此在BlockQueue的pop中才能这么写:

```C++
T pop() {
		std::unique_lock<std::mutex> lock(this->m_Mutex);
		m_Cond.wait(lock, [this]() { return !m_BQueue.empty(); });
		T CallBack = this->m_BQueue.front();	//时刻注意对象生命周期
		this->m_BQueue.pop();
		m_Cond.notify_one();
		return CallBack;
	}
```

```C++
	T CallBack = this->m_BQueue.front();
	/*更建议的写法,明确要求触发移动语义,前提是这个类已经实现.
	T CallBack = std::move(m_BQueue.front());
	*/
```

这一行,触发了拷贝函数.拷贝了一个队首元素的副本,而后续的return函数原本应该执行一次拷贝拷贝构造,但是C++11之后,返回局部变量的时候,编译器会先尝试触发移动构造,而不是拷贝构造,因为原本的元素内容就是function类,已经实现了移动语义,所以这里可以直接返回.	

> 如果被保管的类(本项目是function,已经实现移动语义)没有实现移动语义,那么这里将会处处是坑,可能获取不到原本,可能返回一个局部变量导致未定义行为,也可能直接编译不通过.