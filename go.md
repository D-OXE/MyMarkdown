# 学习记录(go/八股)

## DAY1

### http概述
> 简介: http协议一个**应用层协议,而不是传输层协议**.相比于TCP/UDP,http是更上一层的协议,本质上还是一个传输在网络上的字节流(比特流),是一个**被限定的字符串数据**,在原本发送的基础上添加了一些字符串信息的比特流数据,而不是什么特别难懂的玩意.相当于我在用socket(假设是C/C++)在传输一个**简单的char[]**时候,变成了传递一个有**特殊格式的char[]**而已,这些额外的格式信息就是http协议.相应的,SMTP/FTP协议的信息也是在基础的比特流上做了额外的限制而已.
> 也因为他是应用层协议,所以它是经过TCP/IP协议栈传输,TCP协议自动保证了连接的稳定和顺序收发,http只管发出即可,


要点:
1. http协议是应用层协议,而不是传输层协议.
2. http协议是**被限定的字符串数据**,而不是什么特别难懂的玩意.
3. 其他的应用层协议也是如此,不用想太多.

### 网络资源以及其网络中的表示与传输
> 网络资源在网络上以URI(统一资源标识符,URL是这玩意的子集)被定位,资源存放在各种各样的服务器上,用URI访问具体服务器的具体资源.URI 有两种形式,分别称为 URL 和 URN.
> 统一资源定位符（URL）是资源标识符最常见的形式.URL 描述了一台特定服务器上某资源的特定位置.它们可以明确说明如何从一个精确,固定的位置获取资源.比如http://www.baidu.com/index.html就是一个简单的URL实例. 当然ftp://的也是也URL.
> URI 的第二种形式就是统一资源名（URN）.URN 是作为特定内容的唯一名称使用的,与目前的资源所在地无关.使用这些与位置无关的 URN,就可以将资源四处搬移.通过 URN,还可以用同一个名字通过多种网络访问协议来访问资源.但是**URN 仍然处于试验阶段，还未大范围使用**,直接使用URL即可, 但是要注意之间的区别,尽量不混用.
**Q&A:http如何知道主机在哪里?**
答:URL中的host(主机名)就是服务器的域名,比如http://www.baidu.com/index.html,其中的www.baidu.com就是host.实际上是通过URL间接实现寻址进行访问的
> 当然也可以这样:http://207.200.83.29:80/index.html,直接使用IP代替域名.指定协议的时候,:80这个指定端口可省略.http默认就是80端口.

### http的事务
> http的**事务由一个客户端的请求,以及一个服务器的响应组成**.客户端请求由请求行,请求头,请求体组成,服务器响应由响应行,响应头,响应体组成.这种通信的内容是http报文

常见的http方法:GET POST PUT DELETE HEAD...还有其他方法,但是这五种是最常用的.
- GET:从服务器向客户端发送命名资源
- PUT:将来自客户端的数据存储到一个命名的服务器资源中去
- DELETE:从服务器中删除命名资源
- POST:将客户端数据发送到一个服务器网关应用程序
- HEAD:仅发送命名资源响应中的 HTTP 首部

一个浏览器页面,可能包含多个http事务,一个页面可能包含不同的资源,位于不同的服务器上.

### http报文
> HTTP 报文。HTTP 请求和响应报文的格式很类似。
HTTP 报文包括以下三个部分。
- 起始行:报文的第一行就是起始行，在**请求报文中用来说明要做些什么**，在**响应报文中说明出现了什么情况**。
- 首部字段:起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。**首部以一个空行结束**。添加一个首部字段和添加新行一样简单。
- 主体:空行之后就是**可选的报文主体**了，其中包含了所有类型的数据。请求主体中包括了要发送给 Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，**主体中可以包含任意的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本**。

``` HTML
HTTP/1.1 200 OK					-- 状态
Content-Type: text/HTML 		-- 两行响应头
Content-Length: 1234		
								-- 空行
<!DOCTYPE html>					-- Body,响应体
<html>
  <body>Hello World!</body>
</html>
```

✅ 大多数情况下，HTTP 响应的 Body 就是被请求的资源（如 HTML、图片、音乐等）。
⚠️ 但需注意：
- 检查状态码（如 200 成功，404 未找到）。
- 确认 Content-Type（如 text/html、audio/mp3）。
- 某些请求（如 HEAD、204、304）可能没有 Body。

如果是下载文件，Body 就是文件的原始数据；如果是 API，Body 通常是 JSON/XML。理解这一点对前后端开发和调试非常重要！

### Web的结构组件
> 前面的东西属于Web浏览器和服务器的内容,现在是其他的一些重要组件:代理/缓存/网关/隧道/Agent代理
HTTP 协议中的核心组件（如代理、缓存、网关、隧道、Agent 代理）在网络通信中扮演不同角色，它们协同工作以提升性能、安全性和功能性。以下是它们的详细作用和区别：

---

#### **1. 代理（Proxy）**
##### **作用**：
- **中介转发**：作为客户端和服务器的中间层，代理接收客户端请求并转发给服务器（或反向代理接收服务器请求转发给客户端）。
- **功能扩展**：
  - **匿名性**：隐藏客户端真实 IP（如 VPN 或匿名代理）。
  - **访问控制**：过滤非法请求（如企业防火墙）。
  - **内容过滤**：拦截广告或恶意内容。
  - **负载均衡**：将请求分发到多个服务器（反向代理）。
> 对用户来说,程序就是代理,程序代表用户访问服务器.而Nginx就是一种典型的反向代理,将客户端请求分发到后端服务器
##### **类型**：
- **正向代理**：代表客户端向服务器发送请求（客户端需显式配置代理地址）。
- **反向代理**：代表服务器接收请求（客户端无感知，如 Nginx）。

##### **示例**：
```http
客户端 → 正向代理 → 互联网 → 服务器
客户端 ← 正向代理 ← 互联网 ← 服务器
```

---

#### **2. 缓存（Cache）**
##### **作用**：
- **存储副本**：保存服务器响应的副本（如 HTML、图片、API 结果），减少重复请求和带宽消耗。
- **性能优化**：
  - **客户端缓存**：浏览器缓存静态资源（通过 `Cache-Control` 头控制）。
  - **代理缓存**：CDN 或反向代理缓存热门内容（如 Cloudflare）。

##### **关键 HTTP 头部**：
- `Cache-Control`：定义缓存策略（如 `max-age=3600`）。
- `ETag` / `Last-Modified`：验证资源是否过期。

##### **示例**：
```http
请求：GET /logo.png
响应：200 OK (from cache)  # 直接返回本地缓存，无需访问服务器
```

---

#### **3. 网关（Gateway）**
##### **作用**：
- **协议转换**：连接不同协议或技术的系统（如 HTTP ↔ SOAP、HTTP ↔ gRPC）。
- **功能整合**：
  - **API 网关**：聚合多个微服务接口（如 Kong、Apigee）。
  - **支付网关**：将 HTTP 请求转换为银行内部协议。
> 协议之间的切换.相当于是适配器的作用
##### **与代理的区别**：
- 网关是 **协议转换器**，代理是 **协议透传器**。

##### **示例**：
```http
客户端 → HTTP网关 → 银行内部系统（非HTTP协议）
```

---

#### **4. 隧道（Tunnel）**
##### **作用**：
- **穿透防火墙**：在受限网络中建立加密通道，封装并传输其他协议的数据（如 HTTP 隧道传输 SSH 流量）。
- **典型场景**：
  - **SSH 隧道**：`ssh -D 8080 user@server` 创建 SOCKS 隧道。
  - **VPN**：通过 HTTP 伪装 VPN 流量绕过封锁。

##### **特点**：
- 隧道不解析 HTTP 内容，仅作为数据传输管道。

##### **示例**：
```http
客户端 → HTTP隧道（加密） → 代理服务器 → 目标服务器
```

---

#### **5. Agent 代理（User Agent）**
##### **作用**：
- **客户端代表**：向服务器标识客户端类型和能力（如浏览器、爬虫、移动应用）。
- **功能**：
  - **自动协商**：通过 `User-Agent` 头声明支持的格式（如 `Accept: text/html`）。
  - **行为适配**：服务器根据 Agent 返回不同内容（如移动版/桌面版页面）。

##### **常见 User-Agent**：
- 浏览器：`Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36...`
- 爬虫：`Googlebot/2.1 (+http://www.google.com/bot.html)`

##### **示例**：
```http
GET / HTTP/1.1
User-Agent: curl/7.68.0  # 告知服务器客户端是 cURL
```

---

#### **组件对比总结**
| **组件**  | **角色**          | **典型应用场景**         | **关键特点**             |
| --------- | ----------------- | ------------------------ | ------------------------ |
| 代理      | 请求转发/过滤     | 匿名访问、负载均衡       | 可修改请求/响应          |
| 缓存      | 存储响应副本      | CDN、浏览器缓存          | 减少服务器负载，加速访问 |
| 网关      | 协议转换/接口聚合 | API 网关、支付系统       | 跨协议通信               |
| 隧道      | 加密穿透网络      | SSH over HTTP、企业VPN   | 不解析内容，纯传输       |
| Agent代理 | 标识客户端        | 浏览器、爬虫、移动端适配 | 通过 HTTP 头部声明能力   |

---

#### **协同工作示例**
1. **用户访问网站**：
   - **浏览器（Agent）** 发送请求 → **CDN（缓存+反向代理）** → 若未命中缓存，请求到达 **API 网关** → 网关调用后端微服务。
2. **企业安全访问**：
   - 员工通过 **HTTP 隧道** 连接公司内网 → 请求经过 **正向代理** 过滤 → 访问内部 **网关** 转换协议。

理解这些组件有助于设计高性能、安全的网络架构！

## DAY2

### TCP链接建立全过程

**1. 三次握手 :**

- 客户端向服务器发起请求, 发送一个SYN报文(请求建立), 附带一个seq报文, 假设是x, 

- 服务器如果接受到, 就会回复一个ACK报文, seq = x + 1, (和客户端的SYN作为一对), 然后也发送一个SYN报文, 表示同意建立(并发送序列号y) ,

- 客户端在收到SYN报文也会回复一个ACK.链接建立.

> 三次握手的作用是**确保双方都能进行正常的收发**.

**2. 四次挥手:**(假设A是先结束的一端,B是后结束收发的一端)

- A端发送FIN表示本端数据发送完毕(seq = x),进入 *FIN_WAIT_1* 状态.

- B端接受FIN之后,发送ACK(seq = x + 1),同时进入 *CLOSE_WAIT* 状态.A端接受到ACK之后进入 *FIN_WAIT_2* 状态.

- 当B处理完自身的数据之后, 也会发送一个FIN报文(seq = v),并且自身进入 *TIME_WAIT* 状态, 此时 A 接受FIN之后,发送一个ACK 到B ,然后等待 2MSL(Maximum Segment Lifetime)时间长度之后就关闭链接.

> 四次挥手是因为传输是双工的.需要两端都关闭.另外,晚关闭的(如假设的B端),有可能需要额外的时间处理本端的数据,比如A可能结束发送,但是B还有没发送的,B还需要继续发送. 另外, A等待的这个2MSL时间就是socket编程中地址复用的原因, **因为就算大多数TIME_WAIT是发生在客户端, 也还是会有发生在服务器的, 但是服务器是无法接受这样的等待的.因此服务器需要地址复用.**而不是因为是后发FIN的没有进入TIME_WAIT,还需要复用,只是有时候,先发FIN的是服务器而已.

### 谁建立的TCP链接?

建立TCP链接的是客户端的connect函数 + 服务器的listen函数,以及内核的协议栈.

- connect: 主动发起TCP链接,发送SYN报文, 触发3次握手机制

- listen: 监听端口, 允许内核接受链接请求.

- 内核协议栈: 完成3次握手, 维护链接队列.

> accept函数只是从已经连接成的TCP链接中取一个出来进行处理而已.**也就是说,程序中就算不写accept,一样能成功建立链接,但是没法正常处理罢了**. 因此, 如果**客户端在服务器执行accept之前就开始发送数据, 本质上是可以的**, 这些数据会被**存在缓冲区**中, 但是如果accept迟迟不肯调用, 则缓冲区满,**会触发TCP的流量控制机制(TCP是安全的协议 ,保证不重复,不丢失,按顺序到达.不要忘了)**, 直到accept被调用,缓冲区中的数据被处理为止.(当然了,也有极端情况--> Keep-Alive 超时.)
> 此时客户端会被阻塞或者报错,取决于是阻塞模式还是非阻塞模式:
> 	是否阻塞/报错取决于客户端模式：
> 		阻塞模式 → send() 卡死。
> 		非阻塞模式 → send() 失败并返回 EWOULDBLOCK。

## DAY3 

### go的结构体内嵌/方法内嵌


### go接口作为传参的经典问题辨析

```go
const debug = true	//当debug = false时候,触发panic:out.Write([]byte("done!\n"))

func main() {
	var buf *bytes.Buffer
	if debug {
		buf = new(bytes.Buffer) // enable collection of output
	}
	f(buf) // NOTE: subtly incorrect!
	if debug {
		// ...use buf...
	}
}
// If out is non-nil, output will be written to it.
func f(out io.Writer) {
	// ...do something...
	if out != nil {
		out.Write([]byte("done!\n"))
	}
}

```

在这个简单的例子中,如注释所说,当debug = false,时候,`out.Write([]byte("done!\n"))` 这里会发生panic.原因有以下几点:

- 空接口调用任何方法都会触发panic

- go的**接口**变量都有两个属性,**动态类型/动态值**,**两者只要有一个是nil,则方法不能被调用**.否则panic.

但是这是个经典问题,**最简单的办法就是将传入的 buf变量(类型原本是 *bytes.Buffer),设置为 io.Writer 接口**.因为这样, **函数形参就不会被传入的实参进行动态类型赋值**,从而在原本程序的流程上,out == nil 就恒成立了(因为此时接口的动态类型没有被赋值导致变化,依旧是nil.go中,接口只声明不赋值,则两个值都视为nil,即便是var inter io.Writer也一样),但是当实参在上述例子中不是io.Writer 类型的接口时候, 形参就发生了一次拷贝, 动态类型不再为nil, 整个 out 变量就不再是nil了, 然后就因为调用了nil动态值, 发生panic.

> 要点: 
> 1. 接口只声明不赋值,则两个值都视为nil,此时是真正的nil接口.两者有一个不是nil, 则接口不是nil接口
> 
> 2. 形参接口类型与实参不同, 会发生动态类型的拷贝.

### go接口的无缝替换使用原则

对于go, 只要实现了某个接口的函数签名, 就是实现了这个接口, 但是一个类实例可能同时实现多个接口的全部方法, 此时, 如果想接口互相转换, 就必须满足一个原则: **假设 A 实现的方法 > B 实现的方法数量,那么, B接口的实例可以赋值给 A ,但是A不能赋值给B接口类型,因为根本上说,B没有实现A所有的方法,B的实例不属于A接口.**

> 多方法的接口 不能  赋值给 少方法的接口 (前提当然是包含关系而不是交集关系): 
> abc := a     ----> 可以
> a:= abc      ----> 不行
> 很好理解,因为想把某个东西当作另一个东西使用,就需要实现目标的所有方法,让自己变成目标的类.

**有待补充**


### go的方法内嵌/结构体内嵌

1. **结构体内嵌**

将一个结构体作为另一个结构体的成员就会这样. 新的结构体直接可以访问匿名结构体的成员,相当于匿名结构体的成员被升格了. 不过 ,赋值的时候,需要写明匿名结构体的字段,如下例:

```go
type A struct {
    FieldA int
}

type B struct {
    A       // 匿名嵌入结构体A
    FieldB string
}

b := B{A: A{FieldA: 42}, FieldB: "hello"}

fmt.Println(b.FieldA) // 直接访问A的字段，输出42
```

嵌套冲突:

- 如果外层结构体和内嵌结构体有同名字段，**外层字段会优先**。(不可喧宾夺主)

- 必须显式指定内嵌结构体名访问被覆盖的字段：

```go
type C struct {
    A
    FieldA string // 与外层同名字段覆盖
}

c := C{A: A{FieldA: 100}, FieldA: "override"}
fmt.Println(c.FieldA)         // 输出 "override"（外层优先）
fmt.Println(c.A.FieldA)       // 输出 100（显式访问内嵌字段）
```

2. **方法内嵌**

内嵌结构体的方法,外层结构体现在也可以使用:

```go
func (a A) MethodA() {
    fmt.Println("MethodA called")
}

b := B{}
b.MethodA() // 直接调用A的方法，输出 "MethodA called"
// 等价于 b.A.MethodA()
```

- 如果外层结构体定义了同名方法，会**覆盖内嵌结构体的方法**(不可喧宾夺主, 永远是外层的优先)

- 通过内嵌结构体，外层结构体可以隐式实现接口

> 以上特性, 间接的实现了go的OOP特性.实现了继承.