# C++八股
## auto_ptr被丢弃的原因:
C++98 引入的 `auto_ptr` 最终在 C++17 中被正式移除，主要原因在于其存在严重的设计缺陷，尤其是在所有权转移语义上容易导致潜在的问题。以下是它被废弃的核心原因：

---

### 1. **隐式的所有权转移**
   - **问题**：`auto_ptr` 的拷贝构造函数和赋值运算符会**隐式转移所有权**（原指针变为 `nullptr`），而这一行为不符合直觉，容易引发难以察觉的 Bug。
   - **示例**：
     ```cpp
     auto_ptr<int> p1(new int(42));
     auto_ptr<int> p2 = p1;  // p1 现在为空，所有权转移到 p2
     cout << *p1;  // 运行时崩溃（解引用空指针）
     ```
   - **后果**：开发者可能无意间转移了所有权，导致后续代码访问无效指针。

---

### 2. **与 STL 容器不兼容**
   - **问题**：STL 容器（如 `vector`）要求元素支持可预测的拷贝语义，但 `auto_ptr` 的拷贝会转移所有权，破坏容器的完整性。
   - **示例**：
     ```cpp
     vector<auto_ptr<int>> v;
     v.push_back(auto_ptr<int>(new int(10)));
     v.push_back(auto_ptr<int>(new int(20)));
     // 排序或拷贝容器会导致某些元素意外变为空
     ```
   - **后果**：此类操作会导致容器内部分指针失效，行为未定义。

---

### 3. **缺乏对数组的支持**
   - **问题**：`auto_ptr` 通过 `delete` 释放资源，无法正确处理动态数组（`new[]`），导致内存泄漏。
   - **示例**：
     ```cpp
     auto_ptr<int[]> arr(new int[10]);  // 错误！会导致未定义行为
     ```

---

### 4. **替代方案的兴起**
   - C++11 引入了更安全的智能指针：
     - **`unique_ptr`**：明确所有权唯一，支持显式移动语义（需使用 `std::move`），避免隐式转移。
     - **`shared_ptr`** 和 **`weak_ptr`**：支持共享所有权，避免循环引用。
   - **优势**：
     - 显式所有权转移（通过 `std::move`）更符合现代 C++ 的语义。
     - 支持自定义删除器（如 `delete[]`），可安全管理数组。
     - 与 STL 容器完全兼容。

---

### 5. **语言标准的演进**
   - C++11 明确将 `auto_ptr` 标记为 **`deprecated`**，最终在 C++17 中彻底移除，强制开发者迁移到更安全的替代方案。

---

### 总结
`auto_ptr` 的设计违背了 C++“明确优于隐式”的原则，其隐式所有权转移和与 STL 的冲突导致它成为历史遗留问题。现代 C++ 中应始终使用 `unique_ptr`、`shared_ptr` 或 `weak_ptr`，它们通过更严格的语义和编译时检查避免了 `auto_ptr` 的缺陷。

> unique_ptr如今始终是这个指针的上位替代.

## C++ 中的指针参数传递和引⽤参数传递
- 指针参数本质上是**值传递**,修改指针所指向的位置,就可以达到修改原本变量的效果.
- 引⽤参数传递过程中，被调函数的形式参数也作为局部变量放进来的实参变的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量中的实参变量在栈中开辟了内存空间，但是这时存放的是由主调函数（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数。

## 关于static关键字
- 这个关键字主要是用来修改变量/函数的储存方式和可见性:**由栈区变更到静态/全局区**.同时**可见性也被限制在本文件(局部变量则是被限制在函数中)**中.生命周期始终是全程序存在.
- 对于类的static函数和变量,则从具体类实例上升到了整个类共有的属性.存储位置也不再是栈区,而是全局/静态区.且static**非常量**变量需要在类外初始化.而**static函数没有this指针**,需要的时候直接通过命名空间::函数名的方法调用,也因此,static函数只能访问其他的static函数和变量.
> 另外,类的虚函数是通过this指针调用的,因此,static函数不能被virtual修饰.


## 关于C++的虚函数机制
- 虚函数表（vtable）：**每个包含虚函数的类**都有一个与之关联的虚函数表，这是一个静态数组，包含了该类所有虚函数的地址。
- 虚表指针（vptr）：这是每个对象中的一个隐藏成员，指向该对象所属类的虚函数表。在对象创建时初始化。

另外,**构造函数不能是虚函数**,理由如下:
- **身份确定性**：当构造函数开始执行时，对象的确切类型已经确定了——就是你正在构造的那个类的类型。因此，不需要通过虚函数来决定调用哪个类的版本，因为那时还不存在从派生类到基类的转换路径。

- **虚表指针的初始化**：虚表指针是在构造过程中设置的，这意味着在构造函数体开始执行之前，对象还没有设置好其虚表指针。如果允许构造函数是虚的，那么在构造函数调用时，编译器将无法知道要使用哪个虚函数表，导致不确定性。

- **逻辑上的不一致性**：构造函数的作用是初始化对象的状态，而虚函数主要用于定义接口和实现运行时的多态行为。这两者的目的和作用不同，将它们混合在一起会导致设计上的混乱。