# C++八股

## DAY1

### auto_ptr被丢弃的原因:

C++98 引入的 `auto_ptr` 最终在 C++17 中被正式移除，主要原因在于其存在严重的设计缺陷，尤其是在所有权转移语义上容易导致潜在的问题。以下是它被废弃的核心原因：

---

#### 1. **隐式的所有权转移**
   - **问题**：`auto_ptr` 的拷贝构造函数和赋值运算符会**隐式转移所有权**（原指针变为 `nullptr`），而这一行为不符合直觉，容易引发难以察觉的 Bug。
   - **示例**：
     ```cpp
     auto_ptr<int> p1(new int(42));
     auto_ptr<int> p2 = p1;  // p1 现在为空，所有权转移到 p2
     cout << *p1;  // 运行时崩溃（解引用空指针）
     ```
   - **后果**：开发者可能无意间转移了所有权，导致后续代码访问无效指针。

---

#### 2. **与 STL 容器不兼容**
   - **问题**：STL 容器（如 `vector`）要求元素支持可预测的拷贝语义，但 `auto_ptr` 的拷贝会转移所有权，破坏容器的完整性。
   - **示例**：
     ```cpp
     vector<auto_ptr<int>> v;
     v.push_back(auto_ptr<int>(new int(10)));
     v.push_back(auto_ptr<int>(new int(20)));
     // 排序或拷贝容器会导致某些元素意外变为空
     ```
   - **后果**：此类操作会导致容器内部分指针失效，行为未定义。

---

#### 3. **缺乏对数组的支持**
   - **问题**：`auto_ptr` 通过 `delete` 释放资源，无法正确处理动态数组（`new[]`），导致内存泄漏。
   - **示例**：
     ```cpp
     auto_ptr<int[]> arr(new int[10]);  // 错误！会导致未定义行为
     ```

---

#### 4. **替代方案的兴起**
   - C++11 引入了更安全的智能指针：
     - **`unique_ptr`**：明确所有权唯一，支持显式移动语义（需使用 `std::move`），避免隐式转移。
     - **`shared_ptr`** 和 **`weak_ptr`**：支持共享所有权，避免循环引用。
   - **优势**：
     - 显式所有权转移（通过 `std::move`）更符合现代 C++ 的语义。
     - 支持自定义删除器（如 `delete[]`），可安全管理数组。
     - 与 STL 容器完全兼容。

---

#### 5. **语言标准的演进**
   - C++11 明确将 `auto_ptr` 标记为 **`deprecated`**，最终在 C++17 中彻底移除，强制开发者迁移到更安全的替代方案。

---

#### 总结
`auto_ptr` 的设计违背了 C++“明确优于隐式”的原则，其隐式所有权转移和与 STL 的冲突导致它成为历史遗留问题。现代 C++ 中应始终使用 `unique_ptr`、`shared_ptr` 或 `weak_ptr`，它们通过更严格的语义和编译时检查避免了 `auto_ptr` 的缺陷。

> unique_ptr如今始终是这个指针的上位替代.

### C++ 中的指针参数传递和引⽤参数传递

- 指针参数本质上是**值传递**,修改指针所指向的位置,就可以达到修改原本变量的效果.

- 引⽤参数传递过程中，被调函数的形式参数也作为局部变量放进来的实参变的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量中的实参变量在栈中开辟了内存空间，但是这时存放的是由主调函数（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数。

### 关于static关键字和const关键字

- 这个关键字主要是用来修改变量/函数的储存方式和可见性:**由栈区变更到静态/全局区**.同时**可见性也被限制在本文件(局部变量则是被限制在函数中)**中.生命周期始终是全程序存在.

- 对于类的static函数和变量,则从具体类实例上升到了整个类共有的属性.存储位置也不再是栈区,而是全局/静态区.且static**非常量**变量需要在类外初始化.而**static函数没有this指针**,需要的时候直接通过命名空间::函数名的方法调用,也因此,static函数只能访问其他的static函数和变量.

> 另外,类的虚函数是通过this指针调用的,因此,static函数不能被virtual修饰.

const修饰变量的就不必说了,主要是这个关键字在类以及类中函数的使用:

- const成员变量在某个具体的实例化的对象中,生命周期中是常量,但是对于这个类,则是可以改变的,毕竟可以创建多个实例化对象,而每个对象的这些属性不必相同,所以**不能在类的声明中初始化 const 数据成员**,而应该在初始化列表中进行.

- const关键字和static关键字是**不能混用的**,根据上一条可以知道,**const变量是依赖某个具体的对象**的,但是static却不是,因此,不仅static与virtual冲突,和const也是冲突的.


### 关于C++的虚函数机制
- 虚函数表（vtable）：**每个包含虚函数的类**都有一个与之关联的虚函数表，这是一个静态数组，包含了该类所有虚函数的地址。
- 虚表指针（vptr）：这是每个对象中的一个隐藏成员，指向该对象所属类的虚函数表。在对象创建时初始化。

另外,**构造函数不能是虚函数**,理由如下:
- **身份确定性**：当构造函数开始执行时，对象的确切类型已经确定了——就是你正在构造的那个类的类型。因此，不需要通过虚函数来决定调用哪个类的版本，因为那时还不存在从派生类到基类的转换路径。

- **虚表指针的初始化**：虚表指针是在构造过程中设置的，这意味着在构造函数体开始执行之前，对象还没有设置好其虚表指针。如果允许构造函数是虚的，那么在构造函数调用时，编译器将无法知道要使用哪个虚函数表，导致不确定性。

- **逻辑上的不一致性**：构造函数的作用是初始化对象的状态，而虚函数主要用于定义接口和实现运行时的多态行为。这两者的目的和作用不同，将它们混合在一起会导致设计上的混乱。

另外,顺带复习一下C++的**重写和覆盖**机制:
**重写  机制触发:**
1. 基类函数**必须是virtual修饰**的函数
2. 基类/派生类**函数名相同**
3. 参数表**包括const关键字在内,必须完全匹配**
4. 返回值需要兼容
5. 访问权限不能变严格

**隐藏  机制触发:**
1. 基类函数**不是 virtual**，即使派生类有相同的函数名，也不会重写，而是隐藏。
2. 基类和派生类的函数**参数列表不同（即使基类是 virtual）**。
3. 派生类的函数**返回类型不兼容（无法协变）**。
4. 基类和派生类的函数**访问权限不同**（不会影响重写，但影响可见性）。

因此,**是不是重写或覆盖,与关键字 override 并没有本质联系**, 但是这个关键字可以检查是否出错,比如我想写一个重写函数,但是因为这样那个原因,少写一个参数或者写错一个,这时候override关键字就可以用于检测是否如愿写对,也有利于代码的可读性.

### 内存分配机制:

#### new/delete和malloc/free

这俩对分别是C和C++的内存分配机制,两者有很大的区别,C是函数式编程,但是C++是OOP编程,在创造一个新对象的时候,不止要分配空间,还需要将空间的变量传递有意义的内容进去,而不是一大块脏数据.

**因此,new对比malloc**,new 是**先分配内存,然后调用这个类的构造函数**,malloc只是单纯的分配,而不管初始化.当然,new在构造基本数据类型时候,new int()和new int是不一样的,带()的才会初始化, 否则和malloc类似,仅在这种情况下.

**delete/free** : delete是先调用析构函数,再释放空间.顺序和new反过来.free只是释放空间.如果用free释放new的某个类,此时假设类保管了fstream类的变量,这个文件流**可能没有正常关闭**,而只是释放了内存,有可能会导致未定义事件.

> 因此,new([])的东西,用delete([])释放, malloc 的用 free 释放就行了.权责分明,不含冲突.


## DAY2

### select/poll/epoll的区别/联系

这三个都是I/O多路复用技术，用于同时监控多个文件描述符的状态变化（可读、可写、异常等），是高性能网络编程的核心机制.

1.**select函数**:

最早,所以缺点也是最多的.不过所有平台都能用,特点:

- 使用fd_set结构来存储文件描述符集合

- 每次调用都需要**将整个fd_set从用户空间拷贝到内核空间**

- 返回后**需要遍历所有fd**来检查哪些就绪

根据特点, 优缺点十分容易总结:

**优点**:

- 跨平台支持好

- 超时精度较高（微秒级）

**缺点**:

- 文件描述符数量有限(通常1024)

- 每次调用都需要重置fd_set

- 线性扫描所有fd，效率低

- 需要多次内存拷贝


2. **poll 函数**

在select的基础上解决了 文件描述符上限问题, 也不需要每次都重置, 同时支持更多事件类型,跨平台属性略低于select.

但是依旧**没解决多次内存拷贝(用户态到内核态)** , **线性扫描所有的fd** 这两核心问题, 因此海量并发链接时候,性能依旧不好.

3. **epoll函数**

解决了几乎所有的问题,但是,linux专属(Mac OS 的是kqueue函数,Windows不知道)

没有文件描述符限制,只返回就绪事件的文件描述符,使用mmap加速内核与用户空间的消息传递,支持水平/边缘触发两种模式.

但是对于少量的文件描述符链接, 性能可能不如poll和select.

**适用场景**
select：需要**跨平台或监控的fd数量很少**时

poll：**fd数量较多但跨平台需求不强**时

epoll：Linux平台下需要**处理大量连接**（特别是非活跃连接多的情况,高并发）

> 要点: **epoll是基于事件驱动,而另外两个是轮询**, 但是都允许进程监视多个文件描述符.以检测文件描述符是否准备好io操作.


## DAY3

### extern 的作用

在C语言中, 原本表示此处引用, 别处定义, 其实和 #include 的作用一样, 为什么要用呢? 因为**可以增加编译速度**.

- 可以避免重复包含大型头文件

- 减少预处理和编译的工作量

- 在大型项目中，可以减少重复编译相同的内容

两者的区别在于: include会引入所有文件内容但是extern不会, **extern核心是声明(告诉编译器,变量存在,只是不在本文件中.)**, **而#include核心是文件展开**, #include会引入大量的文件, 源文件中用到, 用不到的都会引入, 而extern只会引用声明的变量或者函数.(因此extern编译时显得更快)

### extern "C"的作用

**是C++ 中特有的语法**(C语言是不支持的).用于解决 C++ 和 C 混合编程时的**符号命名兼容性问题**.

目的: 告诉 C++ 编译器，被修饰的代码应**按照 C 语言的规则编译和链接**，避免 C++ 的“名称修饰”（name mangling）机制.

C++ 的“名称修饰”（name mangling）机制:C++ 编译器在编译阶段对**函数名、变量名、类名等符号进行改写**的机制(这个机制也是 C++ 的核心机制，用于支持重载、命名空间等特性).比如:

```C++
void foo(int x);
void foo(double x);
void foo(int x, double y);
```
上述三个函数可能会被C++编译器更名为:

foo(int) → _Z3fooi

foo(double) → _Z3food

foo(int, double) → _Z3fooid

> 将参数表的首字母添加进去符号表, 用以实际区分不同的函数符号.

不过即使是这样,**extern的作用也始终是声明**, 不管是变量存在性声明, 还是编译风格声明.

> 不仅这里发生, 还有很多可能发生在C++库提供C的 API时候, 这种时候,就需要extern "C"来避免这个问题.在C++库中**禁止C++编译器对代码进行变量名修改,从而按C编译风格生成库文件**, 否则C编译器链接库可能会遇到函数链接失败的问题,因为函数/变量名在C++编译器编译生成库文件的时候,已经对源文件的变量进行命名修饰.


### 类的虚类,虚类的内存占用

空类大小1 ,其他的大小按变量类型以及个数计算,虚类需要额外加8(64位机器中,一个vptr就是8字节)

> 只要是虚类,就会增加一个vptr的大小,而不会额外增加更多.但是,**多继承的除外**,当一个派生类有多个基类, 是可能会增加vptr数量的, 也就是不止增加一个指针的大小.

另外,顺带复习,虚类的**vtabel,vptr和对象的this指针**共同完成对虚函数的调用:
	当通过基类指针或引用来调用虚函数时，程序首先通过vptr找到相应的vtable，然后根据vtable中的信息调用正确的函数版本。在这个过程中，this指针确保被调用的函数能够访问到正确的对象数据。

对于vtable: 原则上是有虚函数的类每个类都有一张这样的表.

但是有特殊情况: 当一个派生类是**多继承,且每个基类都有虚函数时候**, 派生类需要维护多个vtable来保证使用该基类指针能够正确定位到相应的实现.

### 虚类的构造函数和析构函数

**析构函数设置为虚函数的原因**:**直观的讲,是为了降低内存泄漏或资源不当管理的可能性**.不设置为虚析构函数, 编译器就会调用基类的析构函数, 而自身的资源无法得到正确的清理. 极大概率造成内存泄漏, 或者资源的不恰当管理.

**构造函数不设置为虚函数的原因**: 虚函数机制,是依赖对象构造完成的:

- 虚函数表（vtable） 和 虚指针（vptr） 是在**对象构造期间初始化的**

- 构造函数**如果是虚函数, 则调用构造,就需要vptr,但是此时对象并没有创建,没有vptr**,因此自相矛盾


> 另外, 构造/析构函数都可以调用虚函数,但是不推荐.

> **为什么不推荐在构造中调用**?	当在构造函数中调用虚函数时，实际调用的是当前类的版本，而不是派生类的版本 , 因为派生类并没有构造完成, 直接会调用基类的虚函数表和虚函数指针指向的内容, 此时, 不触发多态行为.

> 为什么不推荐在析构中调用? 析构顺序是 *从派生类到基类，当基类析构函数执行时，派生类部分已经被销毁。*此时 vptr 已经回退到基类的 vtable，因此虚函数调用不会进入派生类。

要点: 构造未完成,或者析构顺序是先外层的派生类,再到内部的基类.

以上两种调用都是反直觉的,反人类的,大可不必.

### 构造/析构执行顺序

构造顺序:

- 基类构造: 但是多继承的时候,按照**继承声明的顺序构造**,而不是初始化列表的顺序

- 成员对象构造: 多个成员时候, 按在**类中的声明顺序构造**,而不是初始化列表顺序

- 本类的构造

> 注意事项: 如果类之间有依靠关系,必须先继承最上层的. B依赖A,则A先继承

例子:(经典的)

```C++
class A { public: A() { cout << "A"; } };
class B { public: B() { cout << "B"; } };
class C : public B, public A {
    A a;
    B b;
public:
    C() : b(), a() { cout << "C"; }
};
```

输出是: B A A B C（基类 B→A，成员 A→B，最后 C）

> 先继承构造,再成员构造,再自身.


### 深浅拷贝的内容.何时调用拷贝

当出现类的等号赋值时，会调⽤拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调⽤默认的拷⻉函数－即浅拷⻉，它能够完成成员的⼀⼀复制。当数据成员中**没有指针时，浅拷⻉是可⾏的**。当涉及到指针的时候,**浅拷贝会导致俩对象的指针指向同一个地址,最后析构的时候发生double free**.

所以此时要深拷贝.深拷贝就是单独new 出内存,存放赋值对象的数据.

> 简言之, 有指针 ----> 深拷贝就完事了,直接new一份数据最安全.


**拷贝构造的时机**

1. 用已存在的对象构造新的对象;

2. 函数**传参是值传递**,而不是引用

3. 函数返回对象,**按值返回且不优化**(C++编译器对很多标准库优化了,虽然是按值返回,但是不会拷贝,触发的是移动构造,将资源转移)

```C++
MyClass createObject() {
    MyClass obj;
    return obj;  // 可能调用拷贝构造（未优化时）
}

int main() {
    MyClass newObj = createObject();  // 可能触发拷贝构造
    return 0;
}
```

4. 容器的插入(push_back),C++11之后应该用emplace_back或者std::move

5. 初始化列表

```C++
struct Wrapper {
    MyClass obj;
};

int main() {
    MyClass obj1;
    Wrapper w = {obj1};  // 拷贝构造调用
    MyClass arr[] = {obj1};  // 拷贝构造调用
    return 0;
}
```

**引申**:关于函数的返回值, 在C++11之后,建议不要再使用引用返回了,除了特殊情况. 因为C++11之后, **值返回 + std::move**就已经可以处理绝大多数问题了, 既高效也语义清晰, 反倒是引用返回, 需要极端注意**悬空引用问题, 就是说,这种情况需要时刻要注意对象的生命周期.**

> 特殊情况:

> 1. 需要修改函数外部的原始对象(操作符重载, 流运算符的链式调用)

> 2. 避免不必要的拷贝，提高性能 (特别是对于大型对象), 比如访问容器的某个对象, 而不是消耗掉的时候.

> 3. 实现某些特定的编程模式或接口

### 拷贝构造为什么必须引用传递而不是值传递

原因: 为了**防⽌递归调⽤.**当⼀个对象需要以值⽅式进⾏传递时，**编译器会⽣成代码调⽤它的拷⻉构造函数**⽣成⼀个副本，如果类 A 的拷⻉构造函数的参数不是引⽤传递，⽽是采⽤值传递，那么就⼜需要为了创建传递给拷⻉构造函数的参数的临时对象，⽽⼜⼀次调⽤类 A 的拷⻉构造函数，这就**是⼀个⽆限递归**。

> 要点: 值传递会调用拷贝,这是编译器的特性, 然后拷贝又需要值, 直接死循环.

### 从源文件到可执行文件

过程 : .cpp -> 预处理(.i)-> 编译(.s)-> 汇编(.o)-> 链接(可执行文件)

输入什么文件,输出什么文件,过程什么样子,都齐了.