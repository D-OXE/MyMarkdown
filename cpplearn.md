# C++八股

## auto_ptr被丢弃的原因:

C++98 引入的 `auto_ptr` 最终在 C++17 中被正式移除，主要原因在于其存在严重的设计缺陷，尤其是在所有权转移语义上容易导致潜在的问题。以下是它被废弃的核心原因：

---

### 1. **隐式的所有权转移**
   - **问题**：`auto_ptr` 的拷贝构造函数和赋值运算符会**隐式转移所有权**（原指针变为 `nullptr`），而这一行为不符合直觉，容易引发难以察觉的 Bug。
   - **示例**：
     ```cpp
     auto_ptr<int> p1(new int(42));
     auto_ptr<int> p2 = p1;  // p1 现在为空，所有权转移到 p2
     cout << *p1;  // 运行时崩溃（解引用空指针）
     ```
   - **后果**：开发者可能无意间转移了所有权，导致后续代码访问无效指针。

---

### 2. **与 STL 容器不兼容**
   - **问题**：STL 容器（如 `vector`）要求元素支持可预测的拷贝语义，但 `auto_ptr` 的拷贝会转移所有权，破坏容器的完整性。
   - **示例**：
     ```cpp
     vector<auto_ptr<int>> v;
     v.push_back(auto_ptr<int>(new int(10)));
     v.push_back(auto_ptr<int>(new int(20)));
     // 排序或拷贝容器会导致某些元素意外变为空
     ```
   - **后果**：此类操作会导致容器内部分指针失效，行为未定义。

---

### 3. **缺乏对数组的支持**
   - **问题**：`auto_ptr` 通过 `delete` 释放资源，无法正确处理动态数组（`new[]`），导致内存泄漏。
   - **示例**：
     ```cpp
     auto_ptr<int[]> arr(new int[10]);  // 错误！会导致未定义行为
     ```

---

### 4. **替代方案的兴起**
   - C++11 引入了更安全的智能指针：
     - **`unique_ptr`**：明确所有权唯一，支持显式移动语义（需使用 `std::move`），避免隐式转移。
     - **`shared_ptr`** 和 **`weak_ptr`**：支持共享所有权，避免循环引用。
   - **优势**：
     - 显式所有权转移（通过 `std::move`）更符合现代 C++ 的语义。
     - 支持自定义删除器（如 `delete[]`），可安全管理数组。
     - 与 STL 容器完全兼容。

---

### 5. **语言标准的演进**
   - C++11 明确将 `auto_ptr` 标记为 **`deprecated`**，最终在 C++17 中彻底移除，强制开发者迁移到更安全的替代方案。

---

### 总结
`auto_ptr` 的设计违背了 C++“明确优于隐式”的原则，其隐式所有权转移和与 STL 的冲突导致它成为历史遗留问题。现代 C++ 中应始终使用 `unique_ptr`、`shared_ptr` 或 `weak_ptr`，它们通过更严格的语义和编译时检查避免了 `auto_ptr` 的缺陷。

> unique_ptr如今始终是这个指针的上位替代.

## C++ 中的指针参数传递和引⽤参数传递

- 指针参数本质上是**值传递**,修改指针所指向的位置,就可以达到修改原本变量的效果.

- 引⽤参数传递过程中，被调函数的形式参数也作为局部变量放进来的实参变的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量中的实参变量在栈中开辟了内存空间，但是这时存放的是由主调函数（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数。

## 关于static关键字和const关键字

- 这个关键字主要是用来修改变量/函数的储存方式和可见性:**由栈区变更到静态/全局区**.同时**可见性也被限制在本文件(局部变量则是被限制在函数中)**中.生命周期始终是全程序存在.

- 对于类的static函数和变量,则从具体类实例上升到了整个类共有的属性.存储位置也不再是栈区,而是全局/静态区.且static**非常量**变量需要在类外初始化.而**static函数没有this指针**,需要的时候直接通过命名空间::函数名的方法调用,也因此,static函数只能访问其他的static函数和变量.

> 另外,类的虚函数是通过this指针调用的,因此,static函数不能被virtual修饰.

const修饰变量的就不必说了,主要是这个关键字在类以及类中函数的使用:

- const成员变量在某个具体的实例化的对象中,生命周期中是常量,但是对于这个类,则是可以改变的,毕竟可以创建多个实例化对象,而每个对象的这些属性不必相同,所以**不能在类的声明中初始化 const 数据成员**,而应该在初始化列表中进行.

- const关键字和static关键字是**不能混用的**,根据上一条可以知道,**const变量是依赖某个具体的对象**的,但是static却不是,因此,不仅static与virtual冲突,和const也是冲突的.


## 关于C++的虚函数机制
- 虚函数表（vtable）：**每个包含虚函数的类**都有一个与之关联的虚函数表，这是一个静态数组，包含了该类所有虚函数的地址。
- 虚表指针（vptr）：这是每个对象中的一个隐藏成员，指向该对象所属类的虚函数表。在对象创建时初始化。

另外,**构造函数不能是虚函数**,理由如下:
- **身份确定性**：当构造函数开始执行时，对象的确切类型已经确定了——就是你正在构造的那个类的类型。因此，不需要通过虚函数来决定调用哪个类的版本，因为那时还不存在从派生类到基类的转换路径。

- **虚表指针的初始化**：虚表指针是在构造过程中设置的，这意味着在构造函数体开始执行之前，对象还没有设置好其虚表指针。如果允许构造函数是虚的，那么在构造函数调用时，编译器将无法知道要使用哪个虚函数表，导致不确定性。

- **逻辑上的不一致性**：构造函数的作用是初始化对象的状态，而虚函数主要用于定义接口和实现运行时的多态行为。这两者的目的和作用不同，将它们混合在一起会导致设计上的混乱。

另外,顺带复习一下C++的**重写和覆盖**机制:
**重写  机制触发:**
1. 基类函数**必须是virtual修饰**的函数
2. 基类/派生类**函数名相同**
3. 参数表**包括const关键字在内,必须完全匹配**
4. 返回值需要兼容
5. 访问权限不能变严格

**隐藏  机制触发:**
1. 基类函数**不是 virtual**，即使派生类有相同的函数名，也不会重写，而是隐藏。
2. 基类和派生类的函数**参数列表不同（即使基类是 virtual）**。
3. 派生类的函数**返回类型不兼容（无法协变）**。
4. 基类和派生类的函数**访问权限不同**（不会影响重写，但影响可见性）。

因此,**是不是重写或覆盖,与关键字 override 并没有本质联系**, 但是这个关键字可以检查是否出错,比如我想写一个重写函数,但是因为这样那个原因,少写一个参数或者写错一个,这时候override关键字就可以用于检测是否如愿写对,也有利于代码的可读性.

## 内存分配机制:

### new/delete和malloc/free

这俩对分别是C和C++的内存分配机制,两者有很大的区别,C是函数式编程,但是C++是OOP编程,在创造一个新对象的时候,不止要分配空间,还需要将空间的变量传递有意义的内容进去,而不是一大块脏数据.

**因此,new对比malloc**,new 是**先分配内存,然后调用这个类的构造函数**,malloc只是单纯的分配,而不管初始化.当然,new在构造基本数据类型时候,new int()和new int是不一样的,带()的才会初始化, 否则和malloc类似,仅在这种情况下.

**delete/free** : delete是先调用析构函数,再释放空间.顺序和new反过来.free只是释放空间.如果用free释放new的某个类,此时假设类保管了fstream类的变量,这个文件流**可能没有正常关闭**,而只是释放了内存,有可能会导致未定义事件.

> 因此,new([])的东西,用delete([])释放, malloc 的用 free 释放就行了.权责分明,不含冲突.